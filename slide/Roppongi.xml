<xml>

<!-- ******** Outline ******** -->

  <page>
    <p align='center'>
      <br/><br/><br/><br/><br/><br/>
      <br/><br/><br/><br/><br/><br/>
      <font face='Times' size='144'><b>Tamacola</b></font>
      <br/><br/><br/><br/><br/><br/>
      <font face='Times' size='48'>でスモールトークを作ろう。</font>
      <br/><br/><br/><br/><br/><br/>
      <font size='48'>山宮 隆</font>
    </p>
  </page>

<!-- ******** Introduction ******** -->
  
  <page>
    <p align='center'><font face='Times' size='72'><u>イントロダクション</u></font></p>
    <p align='center'><font face='Times' size='64'><b>
      <br/><br/>
      Tamarin VM × COLA<br/>
      ↓<br/>
      Tamacola<br/>
    </b></font></p>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Tamarin VM</u></font></p>
    <font face='Times' size='36'><br/><br/><br/>
    <ul>
      <li>オープンソース VM (Adobe Virtual Machine 2).<br/></li>
      <li>「三百万人以上のプロフェッショナルに使われ、先進国中 99% ものインターネット利用可能なデスクトップや多くのデバイスで利用出来る世界一普及しているプラットフォーム。」</li>
    </ul>
    </font>

  </page>

  <page>
    <p><font face='Times' size='64'><u>COLA</u></font></p>
    <font face='Times' size='48'><br/><br/>
    <ul>
      <li>Scheme 風 lisp 言語<br/></li>
      <li>「意味の鎖」を処理するPEGパーサ</li>
    </ul>
    </font>

  </page>

  <page>
    <p><font face='Times' size='64'><u>Tamacola とは</u></font></p>
    <font face='Times' size='48'><br/>
    <ul>
      <li>コンパクトな Scheme 風自己記述言語。PEG パーサ付き。(一万行以下)<br/></li>
      <li>Adobe Flash 上で動きインストール不要。学生さんにも簡単アクセス。</li>
    </ul>
    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Tamacola に無いもの</u></font></p>
    <font face='Times' size='48'><br/><br/>
      <ul>
        <li>末尾呼び出し最適化</li>
        <li>継続</li>
        <li>平行プログラミング</li>
        <li>可変長引数</li>
      </ul>
    </font>
  </page>

<!-- ******** PEG in Tamacola ******** -->

  <page>
    <p align='center'><font face='Times' size='72'><u>Tamacola で<br/>スモールトーク<br/>(のようなもの)を作ろう</u></font></p>
    <font face='Times' size='48'><br/><br/>
      <ul>
        <li>About this slide</li>
        <li>Greetings</li>
        <li>Number Parser</li>
        <li>S-Expression Parser</li>
        <li>Compiler</li>
        <li>Recursion</li>
      </ul>
    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>About the slide tool</u></font></p>
    <font face='Times' size='36'><br/>
    This slide is written in Tamacola, it works like a Smalltalk's Workspace.<br/><br/>
      <ul>
        <li>[Print It] evaluates and prints the result</li>
        <li>[Do It] only evaluates a Tamacola expression</li>
        <li>[PEG] defines a new parser</li>
      </ul>
    </font>
    <br/>
    <font face='Courier New' size='36'>
(+ 3 4)
(throw "Hello, World!")
    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Greeting</u></font></p>
    <br/><br/>
    <font face='Courier New' size='24'>

greeting = "morning" -> "Good Morning!"
         | "evening" -> "Good Evening!"

;; Test

(parse-collection greeting "morning")
(parse-collection greeting "evening")
    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Number Parser</u></font></p>
    <br/>
    <font face='Courier New' size='24'>

dig     = [0123456789]
num     = dig+

;; Test

(parse-collection dig "7")
(parse-collection num "345")
(parse-collection num "xyz")

;; Construct a number

num  = dig+:n -> (string->number (->string n))

    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>S-expression Parser</u></font></p>
    <font face='Courier New' size='18'>
sp   = [ \t\r\n]*       -> 'SPACES

dig  = [0123456789]
num  = dig+ :n sp       -> (string->number (->string n))

char = [+-*/abcdefghijklmnopqrstuvwxyz]
sym  = char+ :s sp      -> (intern (->string s))
        
sexp  = sym
      | num
      | "(" sexp*:e ")" -> (->list e)

;; Tests
(parse-collection sp "    ")
(parse-collection dig "0")
(parse-collection num "345")
(parse-collection char "a")
(parse-collection sym "hello")

(parse-collection sexp "345")
(parse-collection sexp "hello")
(parse-collection sexp "(hello world)")
(parse-collection sexp "(3 4)")
(parse-collection sexp "(print 4)")

    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Compiler</u></font></p>
    <font face='Courier New' size='14'>
len   = .*:x                        -> (length (->list x))
insts = inst* :xs                   -> (concatenate (->list xs)) 
                                        
inst  = is-number:x                 -> `((pushint ,x))
      | is-symbol:x                 -> `((getlex ((ns "") ,(symbol->string x))))
      | '( '+ inst:x inst:y )       -> `(,@x ,@y (add))
      | '( '- inst:x inst:y )       -> `(,@x ,@y (subtract))
      | '( '* inst:x inst:y )       -> `(,@x ,@y (multiply))
      | '( '/ inst:x inst:y )       -> `(,@x ,@y (divide))
      | '( inst:f &amp;len:n insts:a )  -> `(,@f (pushnull) ,@a (call ,n))

;; User defined predicates
(define is-number
  (lambda (*stream* *parser*)
    (if (number? (peek *stream*))
        (begin (set-parser-result *parser* (next *stream*))
               #t)
        #f)))

(define is-symbol
  (lambda (*stream* *parser*)
    (if (symbol? (peek *stream*))
        (begin (set-parser-result *parser* (next *stream*))
               #t)
        #f)))

;; Tests
(parse-collection len '(a b c))
(parse-collection inst '(3))
(parse-collection inst '((+ 3 4)))
(parse-collection inst '((f 3 4)))
(parse-collection insts '(3 4))
    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Mini Lisp</u></font></p>

    <font face='Courier New' size='18'>
program = inst:x  ->
`(asm
  (method (((signature
             ((return_type *) (param_type ()) (name "program")
              (flags 0) (options ()) (param_names ())))
            (code ((getlocal 0)
                   (pushscope)
                   ,@x
                   (returnvalue))))))
  (script (((init (method 0)) (trait ())))))

;; Test
(define asm (parse-collection program '((print (+ 3 4)))))
asm

(define code (call-with-output-bytes
               (lambda (port) (write-asm asm port))))
(bytes->list code)

(load-byte-codes code '())
    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Recursion (Left? Right?)</u></font></p>

<font face='Times' size='32'>
<p align='center'>PEG doesn't support left recursion,<br/>but Arabic Numbers are left recursion:<br/>
3456 = (((3 * 10 + 4) * 10 + 5) * 10 + 6)</p>
</font>

    <font face='Courier New' size='18'>
;; Use fold-left
dig   = [0123456789]:d -> (- d 48)
numR  = dig:x dig*:xs  -> (fold-left
                            (lambda (n d) (+ (* n 10) d))
                            x
                            (->list xs))

;; Use left-recursion
dig   = [0123456789]:d -> (- d 48)
numL  = numL:n dig:d   -> (+ (* n 10) d)
      | dig
numLS = numL

;; Tests
(parse-collection numR "345")
(parse-collection numLS "345")
    </font>

  </page>

<!-- ******** Implementation ******** -->

  <page>
    <p align='center'><font face='Times' size='72'><u>Implementation</u></font></p>
    <br/><br/>
    <font face='Times' size='48'>
      <ul>
        <li>Tools</li>
        <li>Build Process</li>
        <li>Assembler</li>
        <li>Boot from COLA</li>
        <li>Unit Testing framework</li>
        <li>Frame Layout</li>
        <li>Macros</li>
        <li>Eval</li>
      </ul>
    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Tools</u></font></p>
    <font face='Times' size='36'>
      <ul>
        <li>tamacc: Tamacola Compiler</li>
        <li>tamacola: Tamacola Shell</li>
      </ul>
    </font>
    <br/><br/>
    <img src='tools.png'/>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Build Process</u></font></p>
    <p align='center'><font face='Times' size='36'>
      3 sets of mkpeg, tamacc, and mkswf.<br/>
      <br/>
      Boot-strapping phase (COLA VM)<br/>
      in COLA
      <br/>↓<br/><br/>
      Stage1: Hybrid Phase (Tamarin VM)<br/>
      in Tamacola function + COLA macro
      <br/>↓<br/><br/>
      Stage2: Production Phase (Tamarin VM)<br/>
      in Tamacola
    </font></p>
  </page>

  <!-- page>
    <p><font face='Times' size='64'><u>Build Process</u></font></p>
    <img src='buildprocess.png' />
  </page -->

  <page>
    <p><font face='Times' size='64'><u>Assembler</u></font></p>
    <font face='Times' size='28'>

      "Hello, World" program written in ABCSX
      <br/>
    </font>
    <font face='Courier New' size='18'>
(asm
 (method
  (((signature
     ((return_type *) (param_type ()) (name "hello")
      (flags 0) (options ()) (param_names ())))
    (code
     ((getlocal 0)
      (pushscope)
      (findpropstrict ((package "") "print"))
      (pushstring "Hello, World!!")
      (callproperty ((package "") "print") 1)
      (returnvoid))))))
 (script (((init (method 0)) (trait ())))))
     </font>
    <font face='Times' size='28'>
      <br/>
      <ul>
        <li>ABCSX (ABC in S-eXpression) is an assembler and disassembler for ABC (Adobe Byte Code).</li>
        <li>S-expression is used to describe a program.</li>
        <li>ABCSX runs on COLA / Racket (PLT) / Gauche.</li>
      </ul>
    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Boot from COLA</u></font></p>
    <font face='Times' size='36'>
      <br/>
      Necessary libraries:
      <br/><br/>
      <ul>
        <li><b>Unit Testing framework</b> (SRFI-78 check).</li>
        <li>List manipulations (map, fold, ...).</li>
        <li>String functions (substring, verious conversion).</li>
        <li>Generic functions (define-generic, define-method).</li>
        <li><b>Bitwise operators and byte streams</b> (write-byte, ...).</li>
        <li>Pretty printer.</li>
      </ul>
    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Unit testing framework</u></font></p>
    <br/>
    <font face='Times' size='32'>
      A simple subset of SFRI-78.
    <br/><br/>
    <font face='Courier New' size='28'>

(check '(cola is cool) => '(cola is cool))
(check '(cola is cool) => '(cola is lukewarm))

    </font>
    <br/><br/><br/><br/>
      File naming convention (based on the Go language)
    <br/><br/>
    <font face='Courier New' size='28'>
target:          source:
runtime/std.k -> runtime/std-test.k
    </font>


    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Frame Layout</u></font></p>
    <font face='Courier New' size='18'>
class Obj {
  function f(x, y) {
    var g = function(z) { return h(x, 30) };
    g(y); // (← The picture below shows the stack here.)
  }
}
var obj = new Obj();
obj.f(10, 20);
    </font>
    <img src='stack.png' />
  </page>

  <!-- page>
    <p><font face='Times' size='64'><u>Runtime</u></font></p>
  </page -->

  <page>
    <p><font face='Times' size='64'><u>Macros</u></font></p>
    <font face='Times' size='24'>
    Macro is used as begin, and, or, cond, let*, list, peg parsers...
      <br/><br/>
      (define-form name argument expander)
      <br/>
      <br/>
      <font face='Courier New' size='24'>
(define-form begin e (cons 'let (cons '() e)))

(macroexpand-1 (begin foo bar buz))
      </font>
      <br/><br/>
      (define-pattern (template pattern) ...)
      <br/><br/>
      <font face='Courier New' size='24'>
(define-pattern
  ((cond)                   ())
  ((cond (c0 . b0) . rest)  (if c0
                                (begin . b0)
                                (cond . rest))))

(macroexpand-1 (cond (first (somethig))
                     ('else (otherwise))))
      </font>
    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Eval</u></font></p>
      <br/>
    <font face='Times' size='36'>
      Console (avmshell) environment<br/>-- abc code, synchronous
      <br/><br/>
      <font face='Courier New' size='24'>
avmplus.Domain.
  loadBytes(bytes:ByteArray)
      </font>
      <br/><br/><br/>
      Adobe Flash environment<br/>-- swf data, asynchronous
      <br/><br/>
      <font face='Courier New' size='24'>
flash.display.Loader.
  loadBytes(bytes:ByteArray,
            context:LoaderContext = null)
      </font>
    </font>

  </page>

<!-- ******** Applications ******** -->

  <page>
    <p align='center'><font face='Times' size='72'><u>Applications</u></font></p>
    <br/><br/>
    <font face='Times' size='48'>
      <ul>
        <li>Workspace</li>
        <li>Extensions: Optimization, Left recursion (Yoshiki)</li>
        <li>Other languages: Particles, ...(Yoshiki)</li>
      </ul>
    </font>
  </page>

<!-- ******** Discussions ******** -->


  <page>
    <p align='center'><font face='Times' size='72'><u>Discussions</u></font></p>
    <br/><br/>
    <font face='Times' size='48'>
      <ul>
        <li>Code size</li>
        <li>Benchmarks</li>
      </ul>
    </font>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Code size</u></font></p>
    <br/>
    <p align='center'><img src='loc.png' align='center'/></p>
  </page>

  <page>
    <p><font face='Times' size='64'><u>Benchmarks</u></font></p>
    <br/>
    <img src='benchmarks.png'/>
    <br/><br/><br/><br/><br/><br/>
    
    <font face='Times' size='24'>
      (Small number is faster)
    </font>
    <font face='Times' size='24'>
      <br/>
      <ul>
        <li>Fibonacci: The first 36 Fibonacci numbers recursively.<br/></li>
        <li>Sieve: The prime numbers up to 8,190 in the Eratosthenes Sieve algorithm, repeats it 3,000 times.<br/></li>
        <li>Sieve with Vector: uses Vector instead of Array to see the impact of parametric types.<br/></li>
      </ul>
    </font>
  </page>

<!-- ******** Conclusions ******** -->

<page>
    <p align='center'><font face='Times' size='72'><u>Conclusions</u></font></p>
    <font face='Times' size='36'>
      <br/>
      <br/><br/>
      <ul>
        <li>Compact self hosting lisp compiler</li>
        <li>PEG parser generator / list transformer</li>
        <li>Run on Adobe Flash</li>
        <li>Dynamic programming environment for the Web</li>
      </ul>
    </font>
  </page>
</xml>
