
;; (require "stream.k")

(define-pattern ((UP-TO-END)    (to-string (up-to-end *stream*))))
(define-pattern ((RETURN value) (begin (set-parser-result *parser* value) #t)))
(define-pattern ((ATEND?)       (at-end? *stream*)))
(define-pattern ((PEEK)	        (peek *stream*)))
(define-pattern ((NEXT)	        (next *stream*)))
(define-pattern ((RESULT)       (parser-result *parser*)))
(define-pattern ((SAVE . exprs) (let ((_p_ (position *stream*))) . exprs)))
(define-pattern ((FAIL)	        (begin (set-position *stream* _p_) ())))
(define-pattern ((SUCCEED)      (begin (set-position *stream* _p_) #t)))
(define-pattern ((GROUP expr)   (let ((_g_ (token-group-new))) (and expr (RETURN _g_)))))
(define-pattern ((APPEND expr)  (and expr (begin (token-group-append _g_ (parser-result *parser*)) #t))))
(define-pattern ((ANY)	        (and (not (ATEND?)) (RETURN (NEXT)))))
(define-pattern ((OBJ expr)     (and (=== expr (PEEK)) (RETURN (NEXT)))))

(define-pattern ((SEQ expr)     (SAVE (let ((_a_ expr))
                                        (let ((_i_ 0)
                                              (_l_ (array-length _a_)))
                                          (while (and (< _i_ _l_) (=== (array-at _a_ _i_) (PEEK)))
                                                 (RETURN (NEXT))
                                                 (set! _i_ (+ _i_ 1)))
                                          (or (=== _i_ _l_) (FAIL)))))))

(define-pattern ((CLASS chars)	((match-class chars) *stream* *parser*)))

(define-pattern ((PRED expr)    (SAVE (if expr (SUCCEED) #f))))
(define-pattern ((NOT expr)     (SAVE (if expr (FAIL) #t))))
(define-pattern ((AND . exprs)  (SAVE (or (and . exprs) (FAIL)))))
(define-pattern ((OR . exprs)   (or . exprs)))
(define-pattern ((STRUCT expr)  (let ((token (PEEK)))
                                  (and (or (pair? token) (null? token))
                                       (let (_result_)
                                         (let ((*stream* (list-stream-on token)))
                                             (set! _result_ expr))
                                         (and _result_ (let () (NEXT) #t)))))))
(define-pattern ((OPT expr)     (GROUP (begin (APPEND expr) #t))))
(define-pattern ((MANY expr)    (GROUP (begin (while (APPEND expr)) #t))))
(define-pattern ((MANY1 expr)   (GROUP (and (APPEND expr) (begin (while (APPEND expr)) #t)))))
(define-pattern
  ((RULE name)        (name *stream* *parser*))
  ((RULE name . args) (let ((*stream* (list-stream-on (list . args))))
                        (name *stream* *parser*))))

(define-pattern ((STORE id expr) (and expr (begin (set! id (RESULT)) #t))))
(define-pattern ((SOURCE expr)  (SAVE (and expr (RETURN (token-stream-group-from *stream* _p_))))))
(define-pattern ((STRING expr)  (and expr (RETURN (->string (RESULT))))))
(define-pattern ((NUMBER r expr) (and expr (RETURN (string->number-radix (->string (RESULT)) r)))))
(define-pattern ((DOUBLE expr)	(and expr (RETURN (string->double (->string (RESULT)))))))

(define-pattern ((define-rule id vars expr)
  (define id (lambda (*stream* *parser*) (let vars expr)))))

